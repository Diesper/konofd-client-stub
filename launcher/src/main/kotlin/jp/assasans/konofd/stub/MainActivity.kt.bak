package jp.assasans.konofd.stub

import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.util.Base64
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material3.Button
import androidx.compose.material3.Checkbox
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.RadioButton
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.saveable.Saver
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.core.content.edit
import com.unity3d.player.UnityPlayerActivity
import jp.assasans.konofd.stub.ui.theme.ExportedTheme
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.json.JSONObject
import java.io.IOException
import java.net.HttpURLConnection
import java.net.URL
import java.security.KeyFactory
import java.security.interfaces.RSAPublicKey
import java.security.spec.X509EncodedKeySpec

class MainActivity : ComponentActivity() {
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    enableEdgeToEdge()
    setContent {
      ExportedTheme {
        Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding ->
          MainScreen(
            modifier = Modifier.padding(innerPadding)
          )
        }
      }
    }
  }
}

@Composable
@Preview(showBackground = true)
fun MainScreen(
  modifier: Modifier = Modifier
) {
  val context = LocalContext.current
  val coroutineScope = rememberCoroutineScope()
  val sharedPrefs = context.getSharedPreferences("launcher_settings", Context.MODE_PRIVATE)

  // Custom saver for nullable String state
  val nullableStringSaver = Saver<String?, String>(
    save = { it ?: "" },
    restore = { if(it.isEmpty()) null else it }
  )

  var selectedMethod by rememberSaveable { mutableStateOf("hook") }
  var serverUrl by rememberSaveable { mutableStateOf("https://axel.assasans.dev/static/") }
  var isLoading by rememberSaveable { mutableStateOf(false) }
  var isLaunchEnabled by rememberSaveable { mutableStateOf(false) }
  var isSkipLogoEnabled by rememberSaveable { mutableStateOf(true) }
  var clientVersion by rememberSaveable(stateSaver = nullableStringSaver) {
    mutableStateOf<String?>(
      null
    )
  }
  var publicKeyStatus by rememberSaveable(stateSaver = nullableStringSaver) {
    mutableStateOf<String?>(
      null
    )
  }
  var extractedPublicKey by rememberSaveable { mutableStateOf("") }
  var storedPublicKeyPem by rememberSaveable { mutableStateOf("") }

  // Track whether initial load has completed to prevent re-triggering on recomposition
  var hasInitiallyLoaded by rememberSaveable { mutableStateOf(false) }

  // Load saved settings on startup - only run once
  LaunchedEffect(Unit) {
    if(!hasInitiallyLoaded) {
      val savedMethod = sharedPrefs.getString("method", "hook")
        ?: "hook"
      val savedSkipLogo = sharedPrefs.getBoolean("skip_logo", true)
      val savedUrl = sharedPrefs.getString("server_url", "https://axel.assasans.dev/static/")
        ?: "https://axel.assasans.dev/static/"
      val savedPublicKeyPem = sharedPrefs.getString("public_key_pem", "") ?: ""

      selectedMethod = savedMethod
      isSkipLogoEnabled = savedSkipLogo
      serverUrl = savedUrl
      storedPublicKeyPem = savedPublicKeyPem

      // Validate stored settings
      if(savedUrl.isNotEmpty() && savedPublicKeyPem.isNotEmpty()) {
        try {
          extractedPublicKey = extractModulusFromPem(savedPublicKeyPem)
          clientVersion = null
          publicKeyStatus = null
          isLaunchEnabled = true
        } catch(_: Exception) {
          // If stored PEM is invalid, clear it
          sharedPrefs.edit { remove("public_key_pem") }
          storedPublicKeyPem = ""
        }
      }

      hasInitiallyLoaded = true
    }
  }

  Box(
    modifier = modifier
      .fillMaxSize()
    // .paint(
    //   painter = painterResource(id = R.drawable.background),
    //   contentScale = ContentScale.Crop,
    //   alpha = 0.25f
    // )
  ) {
    Column(
      modifier = modifier
        .fillMaxSize()
        .padding(16.dp)
    ) {
      Text(
        text = "Patching method",
        style = MaterialTheme.typography.bodyLarge
      )

      Spacer(modifier = Modifier.height(8.dp))

      Column {
        RadioButtonWithText(
          selected = selectedMethod == "none",
          onClick = {
            selectedMethod = "none"
            sharedPrefs.edit { putString("method", "none") }
          },
          title = "None",
          subtitle = "Run the game as-is, without any patching."
        )
        RadioButtonWithText(
          selected = selectedMethod == "hook",
          onClick = {
            selectedMethod = "hook"
            sharedPrefs.edit { putString("method", "hook") }
          },
          title = "Hooking",
          subtitle = "Experimental method using instruction patching. Does not cause an error. Does not work with libhoudini."
        )
        RadioButtonWithText(
          selected = selectedMethod == "scan",
          onClick = {
            selectedMethod = "scan"
            sharedPrefs.edit { putString("method", "scan") }
          },
          title = "Off-thread scan",
          subtitle = "Waits until needed constants are loaded in a background thread. Does cause a one-time error."
        )
        CheckBoxWithText(
          selected = isSkipLogoEnabled,
          onClick = {
            isSkipLogoEnabled = !isSkipLogoEnabled
            sharedPrefs.edit { putBoolean("skip_logo", isSkipLogoEnabled) }
          },
          title = "Skip startup logo",
          subtitle = "Skips Sesisoft and Sumzap logos to speed up launch.",
        )
      }

      HorizontalDivider(
        modifier = Modifier
          .fillMaxWidth()
          .padding(top = 16.dp),
        thickness = 1.dp,
      )

      Spacer(modifier = Modifier.height(16.dp))

      OutlinedTextField(
        value = serverUrl,
        onValueChange = {
          serverUrl = it
          // Clear validation state when URL changes
          if(it != sharedPrefs.getString("server_url", "")) {
            isLaunchEnabled = false
            clientVersion = null
            publicKeyStatus = null
            extractedPublicKey = ""
          }
        },
        label = { Text("Server URL") },
        singleLine = true,
        enabled = !isLoading && selectedMethod != "none",
        modifier = Modifier.fillMaxWidth(),
        keyboardOptions = KeyboardOptions.Default.copy(keyboardType = KeyboardType.Uri)
      )

      Spacer(modifier = Modifier.height(8.dp))

      Button(
        enabled = !isLoading && serverUrl.isNotEmpty() && selectedMethod != "none",
        onClick = {
          isLoading = true
          isLaunchEnabled = false
          clientVersion = null
          publicKeyStatus = null

          coroutineScope.launch {
            try {
              // Check versions endpoint
              val versionUrl = "${serverUrl.trimEnd('/')}/versions/4.11.6_prd_372.json"
              val versionResponse = withContext(Dispatchers.IO) {
                makeHttpRequest(versionUrl)
              }

              if(versionResponse != null) {
                // Parse version info
                val versionJson = JSONObject(versionResponse)
                clientVersion = versionJson.optString("version", "4.11.6_prd_372")

                // Check public key endpoint
                val publicKeyUrl = "${serverUrl.trimEnd('/')}/public.pem"
                val publicKeyResponse = withContext(Dispatchers.IO) {
                  makeHttpRequest(publicKeyUrl)
                }

                if(publicKeyResponse != null) {
                  try {
                    extractedPublicKey = extractModulusFromPem(publicKeyResponse)
                    publicKeyStatus = "supported"
                    isLaunchEnabled = true

                    // Save successful configuration
                    sharedPrefs.edit {
                      putString("server_url", serverUrl)
                      putString("public_key_pem", publicKeyResponse)
                    }
                    storedPublicKeyPem = publicKeyResponse
                  } catch(exception: Exception) {
                    exception.printStackTrace()
                    publicKeyStatus = "error: ${exception.message}"
                  }
                } else {
                  publicKeyStatus = "not supported"
                }
              } else {
                clientVersion = "error"
                publicKeyStatus = "error"
              }
            } catch(exception: Exception) {
              exception.printStackTrace()
              clientVersion = "error: ${exception.message}"
              publicKeyStatus = "error"
            } finally {
              isLoading = false
            }
          }
        },
        modifier = Modifier.fillMaxWidth()
      ) {
        Text("Check")
      }

      if(isLoading) {
        Spacer(modifier = Modifier.height(8.dp))
        CircularProgressIndicator(
          modifier = Modifier.align(Alignment.CenterHorizontally)
        )
      }

      Spacer(modifier = Modifier.height(8.dp))

      if(!isLoading && clientVersion != null && publicKeyStatus != null) {
        Text(
          text = "Reported client version: $clientVersion",
          modifier = Modifier.fillMaxWidth()
        )

        Spacer(modifier = Modifier.height(4.dp))

        Text(
          text = "Public key autoconfiguration: $publicKeyStatus",
          modifier = Modifier.fillMaxWidth()
        )
      }

      Spacer(modifier = Modifier.weight(1f))

      Button(
        onClick = {
          val publicKey = if(extractedPublicKey.isNotEmpty()) extractedPublicKey else
            "z7VeNsuYLX//cx/oMxEMxKgvo4/4wusB3QbV3ZLw61AIClNSjvMNbIFBpZxJJ9AinyGXe6C1lmqChfrlhBtODwZugqKeFaAMRN9UGlDRySkhJZkMyeufU8kBBEvHk440KMvYTgCXbwYJKjqXyM9KOgXno8O6g3OEsLXIwGMevg0="
          val intent = Intent(context, UnityPlayerActivity::class.java).apply {
            putExtra("server_url", serverUrl)
            putExtra("public_key", publicKey)
            putExtra(
              "method",
              when(selectedMethod) {
                "none" -> 0
                "hook" -> 1
                "scan" -> 2
                else -> throw IllegalStateException("Unknown method selected: $selectedMethod")
              }
            )
            putExtra("skip_logo", isSkipLogoEnabled)
          }
          context.startActivity(intent)
        },
        enabled = isLaunchEnabled,
        modifier = Modifier
          .fillMaxWidth(),
        contentPadding = PaddingValues(vertical = 24.dp)
      ) {
        Text("Launch game")
      }
    }
  }
}

@Composable
fun RadioButtonWithText(
  selected: Boolean,
  enabled: Boolean = true,
  onClick: () -> Unit,
  title: String,
  subtitle: String?,
) {
  Row(
    verticalAlignment = Alignment.CenterVertically,
    modifier = Modifier
      .fillMaxWidth()
      .clickable(enabled = enabled, onClick = onClick)
      .alpha(if(enabled) 1f else 0.38f)
      .padding(vertical = 12.dp, horizontal = 0.dp)
  ) {
    RadioButton(
      selected = selected,
      enabled = enabled,
      onClick = null // Use Row's clickable instead
    )
    Spacer(modifier = Modifier.width(8.dp))
    Column {
      Text(
        text = title,
        style = MaterialTheme.typography.bodyMedium,
        fontSize = 14.sp,
      )
      if(subtitle != null) {
        Text(
          text = subtitle,
          style = MaterialTheme.typography.bodySmall,
          color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f),
          fontSize = 12.sp,
        )
      }
    }
  }
}

@Composable
fun CheckBoxWithText(
  selected: Boolean,
  enabled: Boolean = true,
  onClick: () -> Unit,
  title: String,
  subtitle: String? = null,
) {
  Row(
    verticalAlignment = Alignment.CenterVertically,
    modifier = Modifier
      .fillMaxWidth()
      .clickable(enabled = enabled, onClick = onClick)
      .alpha(if(enabled) 1f else 0.38f)
      .padding(vertical = 12.dp, horizontal = 0.dp)
  ) {
    Checkbox(
      checked = selected,
      enabled = enabled,
      onCheckedChange = null // Use Row's clickable instead
    )
    Spacer(modifier = Modifier.width(8.dp))
    Column {
      Text(
        text = title,
        style = MaterialTheme.typography.bodyMedium,
        fontSize = 14.sp,
      )
      if(subtitle != null) {
        Text(
          text = subtitle,
          style = MaterialTheme.typography.bodySmall,
          color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f),
          fontSize = 12.sp,
        )
      }
    }
  }
}

private fun makeHttpRequest(urlString: String): String? {
  return try {
    val url = URL(urlString)
    val connection = url.openConnection() as HttpURLConnection
    connection.requestMethod = "GET"
    connection.connectTimeout = 10000
    connection.readTimeout = 10000

    if(connection.responseCode == HttpURLConnection.HTTP_OK) {
      connection.inputStream.bufferedReader().use { it.readText() }
    } else {
      null
    }
  } catch(exception: IOException) {
    exception.printStackTrace()
    null
  }
}

private fun extractModulusFromPem(pemString: String): String {
  // Remove PEM headers and whitespace
  val cleanPem = pemString
    .replace("-----BEGIN PUBLIC KEY-----", "")
    .replace("-----END PUBLIC KEY-----", "")
    .replace("\\s".toRegex(), "")

  // Decode base64
  val keyBytes = Base64.decode(cleanPem, Base64.DEFAULT)

  // Parse as X.509 public key
  val keySpec = X509EncodedKeySpec(keyBytes)
  val keyFactory = KeyFactory.getInstance("RSA")
  val publicKey = keyFactory.generatePublic(keySpec) as RSAPublicKey

  // Get modulus and convert to base64, removing leading zeros
  val modulus = publicKey.modulus
  val modulusBytes = modulus.toByteArray()

  // Remove leading zero bytes
  val trimmedBytes = if(modulusBytes[0] == 0.toByte() && modulusBytes.size > 1) {
    modulusBytes.sliceArray(1 until modulusBytes.size)
  } else {
    modulusBytes
  }

  return Base64.encodeToString(trimmedBytes, Base64.NO_WRAP)
}
